Na >Ordenacao.h terá o primeiro parâmetro sendo o tamanho que vai ser genérico para todos os tipos de algoritmos e o segundo parâmetro é sobre coleta de dados para saber quantas vezes a função é chamada ou repetição de laço, para assim analisar a quantidade de tempo, quantidade de laço e recursões feitas.
No algoritmo de ordenação Bubble Sort dentro do laço for, teremos laço para repetir o processo para garantir a ordenação, o 1 serve para fazer a troca em si, fazendo a troca de toda, a lista volta para o laço e faz a troca da lista de novo se for a mais interna.
No algoritmo de ordenação Selection Sort, foi passado a lista com parâmetro e a variável para armazenar os dados para análise (coleta), o laço for vai percorrer, fazendo o índice e o segundo laço for vai percorrer o restante da lista a partir do índice para procurar o menor, depois de achar o menor, ele faz a troca e acaba. O dados[1].vezesLaco++; é para pegar a quantidade de laços que foram executados para fazer a análise de dados.
No algoritmo de ordenação Insertion Sort, esta procura na lista o menor elemento e joga para as primeiras posições.
O particionar é um algoritmo que vai receber o laço for que vai percorrer a lista e fazer esse quesito de jogar para o lado esquerdo e lado direito, vai retornar o índice do pivô, como por exemplo o meio da lista dessa nova lista. Poderia ter feito tudo no mesmo algoritmo e função do Quick Sort, mas para ter um melhor entendimento, foi separado. 
No algoritmo de ordenação Quick Sort ele se baseia muito num conceito para conquistar, ele elege um pivô( elemento) que no acaso aqui é o ultimo elemento da lista e joga tudo o que é maior que ele no lado direito e tudo que for menor joga para o lado esquerdo, depois ele volta o quick sort passando uma vez o lado esquerdo e uma vez passando o lado direito, nesse lado direito ele vai pegar a lista denovo, eleger um novo pivô na lista que passamos o lado esquerdo e jogar tudo do lado direito desse pivô, o que é maior que ele e tudo o que for menor ficará no lado esquerdo desse pivô, ai vai fazendo isso recursivamente até chegar no último item e depois de ter feito todo o esquerdo fará a mesma coisa para a lista do lado direito, ou seja, ele vai fazer a ordenação dividindo a lista.
O merge como parâmetro ela recebe a lista, tem que receber um índice pro inicio, pro meio e fim para fazer essa ordenação e o tipo de variável para coletar os dados também. O for para passar no final da lista ali, ele vai fazer duas pilhas de listas, ele vai ver o que está encima de uma e o que está encima de outra e começar a juntar. Esse laço basicamente percorre essas pilhas da listas.
No algoritmo de ordenação Merge Sort, segue o mesmo princípio que o do algoritmo Quick Sort, apenas com a diferença de que gasta mais memória e com o conceito de conquistar, a primeira coisa que ele faz é dividir/separar a lista toda em listas menores, a primeira rodada ele vai pegar e dividir toda a lista em duas listas e pegar essas duas listas e dividir em quatro e assim por diante até ter apenas um elemento na lista. Após chegar nessa lista, vai começar a voltar, só que quando fizer isso, vai juntar a lista já ordenando ela. vai receber um inicio e fim, não precisa receber meio, pois vai ser definido conforme vai passando o algoritmo em si que define o meio e para coleta de dados.
No >Uteis.h terá o tempo de execução, a quantidade de laços que foram executados e a quantidade de vezes que a função foi chamada.
No primeiro void chamado criarValoresAleatorio, é uma função que retorna a lista, que mando uma lista e ela retorna com números aleatórios para testar as ordenações já que tem que testar até 10.000 elementos numa lista e outra função para copiar a lista, usando a mesma lista nos vários algoritmos de ordenação para ter o dado certo etc não tendo diferença porque foi passado uma lista de valores diferentes.
Depois tem uma função chamado mostrarDados que é um for que vai para o struct da lista criada e imprimindo na hora da execução as informações que queremos quantidade de dados, tempo de execução, laços de repetição e chamadas de funções.


No >main.cpp:
Na primeira linha é para armazenar os dados que vou usar para fazer o relatório.
Logo após, tem uma lista do tamanho que citei acima na primeira linha, tu tem que usar uma constante pra fazer isso e se tu usar uma variável comum tu não vai conseguir usar, vai dar erro, e chamei a função pra criar listas aleatórias, ai eu criei cópias da primeira lista cada um com o nome de qual algoritmo vai e também chamei  a função cópia lista e foi passado a lista para o que eu quero copiar e a lista para onde vai, repetindo até o último algoritmo de ordenação, o testando.
Abaixo se tem os nomes dos algoritmos de ordenação, os citando, foi pego o tempo do começo, para pegar o tempo de execução o que foi feito? Pego o tempo do clock, o hrario que foi iniciado e o hrario que finalizou, fazendo o hrario atual que é quando ele finalizou menos o hrario que ele começou, fazendo isso para todas as listas e depois no final tem a chamada de função para mostra os dados coletados que precisamos.
